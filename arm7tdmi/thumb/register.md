# レジスタ操作

算術、分岐命令など

## THUMB.1: move shifted register

 bit  |  内容
---- | ----
15-13 | 0b000
12-11 | オペコード
10-6 | オフセット (0-31)
5-3 | Rs - ソースレジスタ (R0..R7)
2-0 | Rd - ターゲットレジスタ (R0..R7)

オペコード(bit12-11):

```
0: LSL{S} Rd,Rs,#Offset     ; 左シフト  Rd = Rs << nn
1: LSR{S} Rd,Rs,#Offset     ; 論理右シフト Rd = Rs >> nn
2: ASR{S} Rd,Rs,#Offset     ; 算術右シフト Rd = Rs >> nn
3: 未使用
```

- 論理右シフト: 右に溢れたbitは捨てられ、左に空いたbitは0埋めされる
- 算術右シフト: 右に溢れたbitは捨てられ、左に空いたbitは元の符号(0 or 1)で埋められる

ARMモードと同様、シフト量0のときは特殊な処理になります。

- LSL#0: シフトは行われません。キャリーの値は不変です。
- LSR/ASR#0 は LSR/ASR#32 として解釈されます。 
- ソースコードで LSR/ASR#0 を指定しようとすると、自動的に LSL#0 としてリダイレクトされます。同様に LSR/ASR#32 は LSR/ASR#0 としてリダイレクトされます。

フラグ:

- Z = 演算結果がゼロ
- N = 演算結果がマイナス(bit31が1)
- C = 演算結果のキャリー (LSL#0のときは不変)
- V = 不変

実行時間: 1S

## THUMB.2: add/subtract

 bit  |  内容
---- | ----
15-11 | 0b00011
10-9 | オペコード
8-6 | 足し引きする値(0..7 オペコードによってRnかnnかどうか変わる)
5-3 | Rs - ソースレジスタ (R0..R7)
2-0 | Rd - ターゲットレジスタ (R0..R7)

オペコード(bit10-9):

```
0: ADD{S} Rd,Rs,Rn   ; Rd=Rs+Rn
1: SUB{S} Rd,Rs,Rn   ; Rd=Rs-Rn
2: ADD{S} Rd,Rs,#nn  ; Rd=Rs+nn
3: SUB{S} Rd,Rs,#nn  ; Rd=Rs-nn
```

フラグ:

- Z = 演算結果がゼロ
- N = 演算結果がマイナス(bit31が1)
- C = 演算結果のキャリー (LSL#0のときは不変)
- V = 演算結果がオーバーフロー

実行時間: 1S

