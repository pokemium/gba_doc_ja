# アセンブリチュートリアル

## はじめに

## Chapter1: メモリ

### アドレッシングモードとバス

CPUは計算をするのは得意ですが、その計算結果を記憶するのが苦手です。

そこでメモリの出番です。GBA には様々なメモリブロックがあり、それぞれ目的を持っています。

これらのメモリブロックは物理的には別のチップにあるにもかかわらず (通常は別のチップにある)、ソフトウェアはそれらを (ほぼ) 連続した単一のブロックとして認識しています。

このメモリにアクセスするには、アドレスと呼ばれるものを使用します。アドレスには、アクセスするメモリブロックまたは領域と、その位置の開始点からのオフセットという2つの情報が含まれています。これは、1つの32ビットの数字として見られます。この数値の最上位8ビットがブロックで、残りのビットがオフセットです。

例えばアドレス`08123456`は

| Prefix | Offset |
|--------|--------|
| 08     | 123456 |

上の例では、アドレスのプレフィックスは`08`であり、これはROMのアドレスであることを示しています。また後半の`123456`はアドレスが示すデータがROM内でオフセット`123456`の位置にあることを示しています。

プレフィックスとメモリ領域の対応は次のようになっています。

| Prefix | Region  |
|--------|---------|
| 08-09  | ROM     |
| 02     | EWRAM   |
| 03     | IWRAM   |
| 05     | Palettes|

メモリの各ブロックは、アドレスバスを介してアクセスされます。バスは、メモリのブロックとの間のデータのやり取りを可能にするコネクションです。

アドレスバスの幅によって、任意の時間にどれだけのデータがそのバス上を移動できるかが決まります。例えば、ROMのアドレスバスの幅は16ビットです。これは、一度に16ビットしかバス上を移動できないことを意味します。ROMから32ビット(以上)を読み出すことは可能ですが、それにはバスを2回(またはそれ以上)移動する必要があります。

GBAには2種類の命令セットがあると聞いたことがあるかもしれません。ThumbとARMの2種類の命令セットがあり、Thumbの方が速いと聞いたことがあるかもしれません。

それには理由があります。THUMBが「速い」のは、1命令あたり16ビットを使うのに対し、ARMは32ビットを使うからです。ARMの命令をROMから読み出すためには、バスを2往復してから実行しなければなりません。THUMBは1回で済むので、ROMからTHUMBを実行する方がARMを実行するよりも高速です。

ARMのコードを32ビットのバスを持つRAMのブロックにコピーしても、同じように速くなります。

上の表のIWRAM（内部WRAM）とEWRAM（外部WRAM）の違いが気になるかもしれません。IWRAMは32ビットのアドレスバスを持っていますが、EWRAMは16ビットのアドレスバスを持っています。EWRAMの方が大きいのに対し、IWRAMの方が32ビット読み出しが高速です。アクセス頻度の高いデータや32ビットのデータ（ポインタなど）はIWRAMに格納されることが多く、それ以外のデータはEWRAMに格納されます。

## Chapter2: CPU

### アーキテクチャ

GBAに搭載されているCPUはARM7TDMIと呼ばれています。ARM7はチップのシリーズを指し、TDMIはこのチップがサポートしている機能に付けられた名前です。例えば、「T」はこのチップがTHUMBモードをサポートしていることを示しています。

ARM7TDMIはARMv4命令セットを実装しており、2つのバージョンの命令セットをサポートしています。

32ビットのARM命令セットと16ビットのTHUMB命令セットです。

命令セットとは、CPUが実行できる操作のリストのことです。各命令は、オペコードで表され、オペコードの機能を制御するさまざまなオペランドがあります。

オペコードは人間には理解しにくいため、人間が覚えやすく、読み書きしやすいニーモニックと呼ばれる文字列にマッピングされています。GBAのカートリッジには16ビットのアドレスバスしかないため、16ビットしかROMから一度に読み込めないため、THUMBの実行速度が速くなっています。

### レジスタ

レジスタは、CPUが直接アクセスして高速に操作できる小さなデータコンテナです。

データを操作するためには、CPUはメモリからレジスタにデータをロードしなければなりません。一度レジスタに入ったデータは、自由に操作することができますが、後でアクセスするために再度メモリに格納することもできます。

ARM7TDMIでは、レジスタには`r0`から`r15`までの番号が付けられており、最後の3つは通常特別な意味を持ちます。各レジスタのサイズは32ビット、つまり4バイトです。レジスタは分割されています。`r8` から `r15` は 上位レジスタ で、`r0` から `r7` は 下位レジスタ です。

THUMBモードでは、ほとんどの場合下位レジスタの使用に制限されており、上位レジスタは一部のオペコードでしか扱うことができません。

### スタック

スタックは上位アドレスから下位アドレスの方向にのびていきます

つまりスタックにPUSHしたときはSPは減り、POPしたときはSPの値が増えます。

```asm
@ push {r0} equivalent
sub sp, #4
str r0, [sp]

@ pop {r0} equivalent
add sp, #4
ldr r0, [sp]
```

### リンクレジスタ

`BL`実行時に、`LR`には自動的に`PC+4`が格納されます。　関数からリターンする時には`LR`の値を`PC`にセットすることでリターンをおこないます。これにはいくつか方法があります。

通常は次のようにしてリターンできます。

```
bx lr
```

関数がネストしてLRをスタックに退避していたときは次のようにしてやる必要があります。

```
pop {r0}
bx r0
```

このコードは、ARMとTHUMBの切り替えが必要で、戻り値がない場合に使用されます。

`BX`はTHUMBコードからARMコードに戻る唯一の方法であるため、正しいCPUモードを設定するためには、このオペコードを使用して戻る必要があります。戻り値がある場合は、単に `r1` が代わりに使用されます。

ARMとTHUMBの切り替えが不要な場合は次のようにしてリターンすることもできます。

```
mov pc, lr
```

or 

```
pop {pc}
```

## Chapter3: 制御フロー

### サブルーチン

サブルーチンはプログラムの基本的な計算単位です。GBA のゲームのほとんどは C 言語でプログラムされているので、コードを関数の集合体として考えると便利です。GBA はシングルスレッドなので、2 つの関数が並列に実行されることはありません。典型的なGBAゲームのコードを見ると、ほとんどのコードはサブルーチンに属しています。

### 呼び出し規約

関数に引数を与える方法はいくつかあり、値を返す方法もいくつかあるので、関数がどのようにこれらのタスクを行うかを記述した呼び出し規約を確立する必要があります。

規約に関する唯一の重要なことは、それが一貫していること、つまりどこでも使用可能でなければならないことです。

呼び出し規約には多くの可能性がありますが、ARMのコードで見られる典型的な規約は次のとおりです。

- 引数は`R0`-`R3`を通して渡す
- それ以上引数が必要な場合はスタックを通して渡す
- 戻り値は`R0`を通して返す
- `R4`-`R11` と `SP` は関数実行前と実行後で値が変わっていてはならない
- 関数は実行後`LR`で指定したアドレスにリターンすべき

上記は32bitのARMプロセッサの標準的な呼び出し規約です。もっと知りたい方は[Wikipedia](https://en.wikipedia.org/wiki/Calling_convention#ARM_.28A32.29)をみてください。

パラメータは `R0` から `R3` に含まれることを想定しているため、関数を呼び出す際にスタックにそれらをプッシュする必要はありません。

ARMの呼び出し規約で関数を呼び出すルーチンでは、`R0` から `R3` には、関数から出力される値が入力される値とは異なる値が格納されていることを想定しなければなりません。ARMの典型的な関数は以下のようになります。

````
push {r4-r5, lr}
bl some_other_function
pop {r4-r5}
pop {r1}
bx r1
````

次のような場合もあります。

````
push {r4-r5, lr}
bl some_other_function
pop {r4-r5, pc}
````

### 比較

意思決定を行うためには、CPUは2つの値を一緒に比較することができなければなりません。ARMv4では、これは比較命令である`CMP`(または比較否定命令である`CMN`)で行われます。この命令を使用すると、2つのレジスタを比較し、この比較結果に基づいて違うアドレスに移動することができます。比較自体は何もしないので、効果を発揮するためには分岐命令の後に続く必要があります。
